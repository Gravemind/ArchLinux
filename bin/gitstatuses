#!/bin/bash

set -euo pipefail

C_RED="\033[1;31m"
C_MAGENTA="\033[1;35m"
C_YELLOW="\033[1;33m"
C_BLUE="\033[1;34m"
C_CYAN="\033[1;36m"
C_WHITE="\033[1;37m"
C_GREEN="\033[1;32m"
C_RESET="$(tput sgr0)"

C_ERROR="$C_RED"
C_OK="$C_GREEN"
C_PULL="$C_MAGENTA"
C_PUSH="$C_CYAN"
C_LOCAL="$C_RED"
C_STAGE="$C_GREEN"

root="."

FETCHALL=0

# Fetch only if last fetch was before
FETCH_IF_OLDER_THAN=$(( "$(date "+%s")" - 60 * 5 )) # 5 minutes ago
# usage: -F to force

tmpdir="$(mktemp -d -t gitstatuses.XXXXXXXXXX)"
trap "{ rm -rf $tmpdir; }" EXIT

logdeb() {
    echo "$@" 1>&2
}

fetchrepo() {
    local repoi="$1"
    local repo="$2"
    cd "$repo"

    if [[ "$FETCHALL" == "1" ]]
    then
        last_fetched="$([ -f .git/FETCH_HEAD ] && stat -c %Y .git/FETCH_HEAD || echo 0)"
        if [[ "$last_fetched" -le "$FETCH_IF_OLDER_THAN" ]]
        then
            (
                git fetch --all
            ) 1>&2 || echo -ne "${C_ERROR}fetch failed${C_RESET} "
            logdeb "$repo: fetched"
        else
            true
            #logdeb "$repo: NOT fetched"
        fi
    fi

    git update-index -q --refresh 2>&1 >/dev/null || echo -ne "${C_ERROR}update-index failed${C_RESET} "

    local count_ahead=0
    local count_behind=0
    local count_local_M=0
    local count_local_D=0
    local count_stage_A=0
    local count_stage_M=0
    local count_stage_D=0
    local count_U=0
    local count_Q=0

    local i=0
    local status=
    while IFS= read -r -u3 -d $'\0' status
    do
        if [[ $i -eq 0 ]]
        then
            if [[ "$status" =~ ahead\ ([0-9]+) ]]
            then
                count_ahead="${BASH_REMATCH[1]}"
            fi
            if [[ "$status" =~ behind\ ([0-9]+) ]]
            then
                count_behind="${BASH_REMATCH[1]}"
            fi
        else
            local s="${status:0:1}"
            local l="${status:1:1}"
            case $l in
                D) ((++count_local_D)) ;;
                M) ((++count_local_M)) ;;
                U) ((++count_U)) ;;
                \?) ((++count_Q)) ;;
                \ ) ;;
                ?) logdeb "$repo: unkown local status \"$s\" in \"$status\""
            esac
            case $s in
                A) ((++count_stage_A)) ;;
                D) ((++count_stage_D)) ;;
                M) ((++count_stage_M)) ;;
                \ ) ;;
                \?) ;;
                ?) logdeb "$repo: unkown stage status \"$s\" in \"$status\""
            esac
        fi
        ((++i))
    done 3< <( git status -z --branch --porcelain=v1 )

    printf "%3d %s " "$repoi" "$repo"

    local count_local=$(( $count_local_M + $count_local_D + $count_U + $count_Q))
    echo -ne "${C_LOCAL}"
    echo -ne "$([[ "$count_local" -gt 0 ]] && echo -n "●")"

    local count_stage=$(( $count_stage_M + $count_stage_A + $count_stage_D ))
    echo -ne "${C_STAGE}"
    echo -ne "$([[ "$count_stage" -gt 0 ]] && echo -n "●")"

    ## branches
    while IFS= read -r -u3 -d $'\n' line
    do
        local ishead=0
        if [[ "$line" =~ ^\* ]]
        then
           ishead=1
        fi
        local branch=
        local ahead=0
        local behind=0
        [[ "$line" =~ ^(\*?\ +[^\ ]+)\ + ]] && branch="${BASH_REMATCH[1]}"
        [[ "$line" =~ ahead\ ([0-9]+) ]] && ahead="${BASH_REMATCH[1]}"
        [[ "$line" =~ behind\ ([0-9]+) ]] && behind="${BASH_REMATCH[1]}"
        if [[ $ahead -gt 0 || $behind -gt 0 ]]
        then
            echo
            echo -n "    "
            if [[ $ahead -gt 0 ]] ; then
                printf "$C_PUSH%2d↑" $ahead
            else
                printf "   "
            fi
            if [[ $behind -gt 0 ]] ; then
                printf "$C_PULL%2d↓" $behind
            else
                printf "   "
            fi
            echo -ne "$C_RESET"
            echo -n " $branch"
        fi
    done 3< <( git branch -v --color=always )

    echo "$C_RESET"

    #logdeb "$repo: done"
}

waitmaxbgjobs() {
    local maxjobs=$1
    while [[ $(jobs -p | wc -l) -ge $maxjobs ]]
    do
        sleep 0.2
    done
}

declare -a repos
i=0
while IFS= read -r -u3 -d $'\0' file
do
    repos[i++]="$(dirname "$file")"
done 3< <(find -L "$root" -name .git -type d -print0 | sort -z)

echo "Processing ${i} repos ..."

i=0
if [[ "$#" -ge 1 ]]
then
    if [[ "$1" = "-f" ]]
    then
        logdeb fetching all
        FETCHALL=1
    elif [[ "$1" = "-F" ]]
    then
        logdeb Force fetching all
        FETCHALL=1
        FETCH_IF_OLDER_THAN=9999999999
    else
        declare -a selectedrepos
        while [[ "$1" =~ ^[0-9]+$ ]]
        do
            repoid="$1"
            shift
            repo="${repos[$repoid]}"
            if [[ -z "$repo" ]]
            then
                echo invalid repo index $repoid 1>&2
                exit 1
            fi
            selectedrepos[i++]="$repo"
        done
        for repo in "${selectedrepos[@]}"
        do
            echo "$repo; $@"
            ( cd "$repo" ; "$@" )
        done
        exit 0
    fi
fi

if [[ "$FETCHALL" == "1" ]]
then
    maxjobs=6 # limit at 6 fetches at the same time
    #ssh-add
else
    maxjobs=$(nproc)
fi

declare -a results
i=0
for repo in "${repos[@]}"
do
    waitmaxbgjobs $maxjobs
    ( fetchrepo $i "$repo" > "$tmpdir/$i" ) &
    ((++i))
done

wait

i=0
for repo in "${repos[@]}"
do
    cat "$tmpdir/$i"
    #echo "$res"
    #printf "%3d %s\n" "$i" "$repo"
    ((++i))
done

