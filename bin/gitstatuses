#!/bin/bash

set -euo pipefail

## catch all errors, even those test with `$?`
# on_error() {
#   echo "Error near line ${1:-\?}: ${2:-error}; exit ${3:-1}"
#   # exit "${3:-1}"
# }
# trap 'on_error ${LINENO}' ERR

C_RED="\033[1;31m"
C_RED_NOBOLD="\033[0;31m"
C_MAGENTA="\033[1;35m"
C_YELLOW="\033[1;33m"
C_BLUE="\033[1;34m"
C_CYAN="\033[1;36m"
C_WHITE="\033[1;37m"
C_GREEN="\033[1;32m"
C_RESET="$(tput sgr0)"

C_ERROR="$C_RED"
C_OK="$C_GREEN"

# status indicators
C_LOCAL="$C_RED"
C_STAGE="$C_GREEN"
C_UNTRACK="$C_RED_NOBOLD"
# branch ahead/behind count
C_PULL="$C_MAGENTA"
C_PUSH="$C_CYAN"
# branch names
C_BR_REMOTE="$C_CYAN"
C_BR_LOCAL="$C_GREEN"
C_BR_HEAD="$C_WHITE"

root="."

FETCHALL=0

# Fetch only if last fetch was before
FETCH_IF_OLDER_THAN=$(( "$(date "+%s")" - 60 * 5 )) # 5 minutes ago
# usage: -F to force

tmpdir="$(mktemp -d -t gitstatuses.XXXXXXXXXX)"
trap "{ rm -rf $tmpdir; }" EXIT

logdeb() {
    echo "$@" 1>&2
}

printfrepo() {
    printf "%3d %s\t" "$1" "$2"
}

fetchrepo() {
    local repoi="$1"
    local repo="$2"
    cd "$repo"

    if [[ "$FETCHALL" == "1" ]]
    then
        last_fetched="$([ -f .git/FETCH_HEAD ] && stat -c %Y .git/FETCH_HEAD || echo 0)"
        if [[ "$last_fetched" -le "$FETCH_IF_OLDER_THAN" ]]
        then
            (
                git fetch --all
            ) 1>&2 || echo -ne "${C_ERROR}fetch failed${C_RESET} "
            logdeb "$repo: fetched"
        else
            true
            #logdeb "$repo: NOT fetched"
        fi
    fi

    git update-index -q --refresh 2>&1 >/dev/null || echo -ne "${C_ERROR}update-index failed${C_RESET} "

    local count_ahead=0
    local count_behind=0
    local count_local_M=0
    local count_local_D=0
    local count_stage_A=0
    local count_stage_M=0
    local count_stage_D=0
    local count_U=0
    local count_Q=0

    local i=0
    local status=
    while IFS= read -r -u3 -d $'\0' status
    do
        if [[ $i -eq 0 ]]
        then
            if [[ "$status" =~ ahead\ ([0-9]+) ]]
            then
                count_ahead="${BASH_REMATCH[1]}"
            fi
            if [[ "$status" =~ behind\ ([0-9]+) ]]
            then
                count_behind="${BASH_REMATCH[1]}"
            fi
        else
            local s="${status:0:1}"
            local l="${status:1:1}"
            case $l in
                D) ((++count_local_D)) ;;
                M) ((++count_local_M)) ;;
                U) ((++count_U)) ;;
                \?) ((++count_Q)) ;;
                \ ) ;;
                ?) logdeb "$repo: unkown local status \"$s\" in \"$status\""
            esac
            case $s in
                A) ((++count_stage_A)) ;;
                D) ((++count_stage_D)) ;;
                M) ((++count_stage_M)) ;;
                \ ) ;;
                \?) ;;
                ?) logdeb "$repo: unkown stage status \"$s\" in \"$status\""
            esac
        fi
        ((++i))
    done 3< <( git status -z --branch --porcelain=v1 )

    # local localstr=
    # #[[ "$(( $count_local_M + $count_local_D + $count_U + $count_Q))" -gt 0 ]] && localstr+="●"
    # [[ "$count_local_M" -gt 0 ]] && localstr+="M"
    # [[ "$count_local_D" -gt 0 ]] && localstr+="D"
    # [[ "$count_U" -gt 0 ]] && localstr+="U"
    # [[ "$count_Q" -gt 0 ]] && localstr+="?"
    # local stagestr=
    # #[[ "$(( $count_stage_M + $count_stage_A + $count_stage_D ))" -gt 0 ]] && stagestr+="●"
    # [[ "$count_stage_M" -gt 0 ]] && stagestr+="M"
    # [[ "$count_stage_A" -gt 0 ]] && stagestr+="A"
    # [[ "$count_stage_D" -gt 0 ]] && stagestr+="D"
    # printfrepo "$repoi" "$repo"
    # echo -ne "${C_LOCAL}$localstr ${C_STAGE}$stagestr"
    #local branches_ident="    "

    local pfmt="${C_LOCAL}%1s${C_STAGE}%1s${C_UNTRACK}%1s"
    local pargs=(
        #"$([[ "$count_local_M" -gt 0 ]] && echo -ne "M")"
        # "$([[ "$count_local_D" -gt 0 ]] && echo -ne "D")"
        # "$([[ "$count_U" -gt 0 ]] && echo -ne "U")"
        "$([[ "$((count_local_M + count_local_D + $count_U))" -gt 0 ]] && echo -ne "●")"
        # "$([[ "$count_stage_M" -gt 0 ]] && echo -ne "M" )"
        # "$([[ "$count_stage_A" -gt 0 ]] && echo -ne "A" )"
        # "$([[ "$count_stage_D" -gt 0 ]] && echo -ne "D" )"
        "$([[ "$((count_stage_M + count_stage_A + count_stage_D))" -gt 0 ]] && echo -ne "●" )"
        "$([[ "$count_Q" -gt 0 ]] && echo -ne "?")"
    )
    local branches_ident="        "

    printf "%3d ${pfmt} ${C_RESET}%s" "$repoi" "${pargs[@]}" "$repo"

    ## branches
    while IFS= read -r -u3 -d $'\n' line
    do
        local c_br_local="$C_BR_LOCAL"
        if [[ "$line" =~ ^\* ]]
        then
            c_br_local="$C_BR_HEAD"
        fi
        local head=" "
        local branch=
        local remote=
        local rembranch=
        local branch=
        local ahead=0
        local behind=0
        [[ "$line" =~ ^\*?\ +([^\ ]+)\ + ]] && branch="${BASH_REMATCH[1]}"
        [[ "$line" =~ \[([^\ /]+)/([^\ ]+): ]] && { remote="${BASH_REMATCH[1]}"; rembranch="${BASH_REMATCH[2]}"; }
        [[ "$line" =~ ahead\ ([0-9]+) ]] && ahead="${BASH_REMATCH[1]}"
        [[ "$line" =~ behind\ ([0-9]+) ]] && behind="${BASH_REMATCH[1]}"
        if [[ $ahead -gt 0 || $behind -gt 0 ]]
        then
            echo
            echo -n "$branches_ident"
            if [[ $ahead -gt 0 ]] ; then
                printf "$C_PUSH↑%-3d" "${ahead}"
            else
                printf "    "
            fi
            if [[ $behind -gt 0 ]] ; then
                printf "$C_PULL↓%-3d" "$behind"
            else
                printf "    "
            fi
            echo -ne "$C_RESET"
            if [[ "$rembranch" != "$branch" ]] ; then
                echo -ne " $C_BR_REMOTE$remote/$rembranch$C_RESET $c_br_local$branch$C_RESET"
            elif [[ "$remote" == "origin" ]] ; then
                echo -ne " $c_br_local$branch$C_RESET"
            else
                echo -ne " $C_BR_REMOTE$remote/$c_br_local$branch$C_RESET"
            fi
        fi
    done 3< <( git branch -vv )

    echo "$C_RESET"

    #logdeb "$repo: done"
}

waitmaxbgjobs() {
    local maxjobs=$1
    while [[ $(jobs -p | wc -l) -gt $maxjobs ]]
    do
        sleep 0.2
    done
}

declare -a repos
i=0
while IFS= read -r -u3 -d $'\0' file
do
    repos[i++]="$(dirname "$file")"
done 3< <(find -L "$root" -name .git -type d -print0 | sort -z)

echo "Found ${i} repos..."

i=0
if [[ "$#" -ge 1 ]]
then
    if [[ "$1" = "-f" ]]
    then
        logdeb fetching all
        FETCHALL=1
    elif [[ "$1" = "-F" ]]
    then
        logdeb Force fetching all
        FETCHALL=1
        FETCH_IF_OLDER_THAN=9999999999
    else
        declare -a selectedrepos
        if [[ "$1" =~ ^[0-9]+$ ]]
        then
            while [[ "$1" =~ ^[0-9]+$ ]]
            do
                repoid="$1"
                shift
                if [[ "$repoid" -lt 0 || "$repoid" -gt "${#repos[@]}" ]]
                then
                    echo invalid repo index $repoid 1>&2
                    exit 1
                fi
                selectedrepos+=("$repoid")
            done
        elif [[ -n "$1" ]]
        then
            selectedrepos=( $(seq 0 $((${#repos[@]} - 1)) ) )
        fi
        for i in "${selectedrepos[@]}"
        do
            repo="${repos[i]}"
            echo
            printfrepo "$i" "$repo"
            echo "; $@"
            ( cd "$repo" ; "$@" || echo -e "${C_ERROR}error: exited $?$C_RESET" ; )
        done
        echo
        exit 0
    fi
fi

if [[ "$FETCHALL" == "1" ]]
then
    # TODO: maxjobs=min(nproc, 6)
    maxjobs=6 # limit at 6 fetches at the same time
    #ssh-add

    # TODO: test for ssh-agent only if password needed ?
    set +e
    keys="$(ssh-add -l 2> /dev/null)"
    res=$?
    set -e
    if [[ $res -ne 0 ]] ; then
        echo -n "No ssh agent running, continue ? [y/n] "
        read -n1 resp
        echo
        if [[ "$resp" != "y" ]] ; then
            echo Aborting
            exit 1
        fi
    elif [[ -z "$keys" ]] ; then
        echo 'No ssh agent keys found, running ssh-add:'
        ssh-add
    fi

else
    maxjobs=$(nproc)
fi

declare -a results
i=0
for repo in "${repos[@]}"
do
    waitmaxbgjobs $maxjobs
    ( fetchrepo $i "$repo" > "$tmpdir/$i" ) &
    ((++i))
done

wait

i=0
for repo in "${repos[@]}"
do
    cat "$tmpdir/$i"
    #echo "$res"
    #printf "%3d %s\n" "$i" "$repo"
    ((++i))
done

