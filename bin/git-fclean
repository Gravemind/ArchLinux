#!/bin/bash

set -euo pipefail

usage() {
    echo -n 'usage: '"$0"' [-h|--help] [-n] [--] [PATH]

Hard cleans PATH working tree (defaults to "."):
- Recurses sub-modules/gits
- git checkout -- PATH
- git clean -xdf -- PATH # untracked and ignored files

'
}

fclean() {
    local clean_fn="$1"
    local path="$2"

    #echo
    pushd "$path" > /dev/null
    echo ":::: fclean $path ..."

    #echo ":::: checkout $path ..."
    #git --no-pager diff --name-only -- "."
    if [[ $clean_fn = "-f" ]]; then
        git checkout -- "."
    fi
    git clean -xd $clean_fn -- "."

    popd > /dev/null
}

clean_fn="-f"

for arg in "$@" ; do
    case "$arg" in
        -h|--help) usage; exit 0; ;;
        -n) clean_fn="-n"; shift; ;;
        --) shift; break; ;;
        -*) echo "$0: error: invalid argument $arg" >&2; exit 1; ;;
        *) break; ;;
    esac
done

paths=( "${@:-.}" )
for path in "${paths[@]}" ; do
    if [[ ! -d "$path" ]]; then
        echo "$0: error: no such directory: $path" >&2
        exit 2
    fi
done

echo -n "Recursively reset and clean $clean_fn ${paths[@]} ? [y/N] "
read -n 1 r
echo
[[ "$r" == "y" ]] || exit 1
echo

for path in "${paths[@]}" ; do
    fclean $clean_fn "$path"
    while read -u3 -d $'\0' -r sub; do
        sub="$(dirname "$sub")"
        fclean $clean_fn "$sub"
    done 3< <(find "$path" -mindepth 2 -name '.git' -print0)
done

echo
echo "All cleaned."
